<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <!-- <link rel="stylesheet" href="css/base.css" /> -->
  <script src="https://code.createjs.com/1.0.0/createjs.min.js"></script>
  <script>
    // 読み込みが終わってから初期化
    window.addEventListener("load", init);

    function init() {
        // ステージを作成
        let stage = new createjs.Stage("myCanvas");
        let w, h

        let collision_manager = new CollisionManager();
        stage.addChild(collision_manager);

        // リサイズイベントを検知してリサイズ処理を実行
        window.addEventListener("resize", handleResize);
        handleResize(); // 起動時にもリサイズしておく

        // リサイズ処理
        function handleResize(event) {
            // 画面幅・高さを取得
            w = window.innerWidth;
            h = window.innerHeight;
            // Canvas要素の大きさを画面幅・高さに合わせる
            stage.canvas.width = w;
            stage.canvas.height = h;
            // 画面更新する
            stage.update();
        }

        // タッチ操作をサポートしているブラウザーならば
        if (createjs.Touch.isSupported() == true) {
        // タッチ操作を有効にします。
        createjs.Touch.enable(stage)
        }



        // オブジェクトの作成
        let rect = new createjs.Shape();
        rect.graphics.beginFill("black").drawRect(0, 0, w, h);
        stage.addChild(rect);

        let move_point = new MovePoint(30, 30);
        stage.addChild(move_point);

        let object_a = new MoveObject();
        object_a.dest_control = true;
        stage.addChild(object_a);
        collision_manager.addList(object_a);

        let object_b = new MoveObject(200,80);
        object_b.x = 100;
        object_b.y = 500;
        stage.addChild(object_b);
        collision_manager.addList(object_b);

        let object_c = new MoveObject(100,100);
        object_c.x = 500;
        object_c.y = 400;
        stage.addChild(object_c);
        collision_manager.addList(object_c);

        // let bmp = new createjs.Bitmap("block202002x4.png");
        // stage.addChild(bmp);


        // tick イベントを登録する
        createjs.Ticker.addEventListener("tick", handleTick);
        createjs.Ticker.timingMode = createjs.Ticker.RAF;

        // 各種マウスイベントを登録する
        rect.addEventListener("click", handleRectClick);

        function handleTick(event) {
          // 画面を更新する
          stage.update();
        }

        //背景クリックイベント
        function handleRectClick(event) {
          move_point.transfar(stage.mouseX, stage.mouseY);
          object_a.set_destination(stage.mouseX, stage.mouseY)
        }
 
    } //init()ここまで


    //---------------- class ----------------//
    class MovePoint extends createjs.Shape {
      constructor() {
        super();
        
        this.graphics.beginStroke("white");
        this.graphics.setStrokeStyle(5);
        this.graphics.drawCircle(0, 0, 40);
      }

      transfar(_x, _y) {
        this.x = _x;
        this.y = _y;
      }
    }

    class MoveObject extends createjs.Container {
      constructor(w=30, h=30, dest_control=false, stc=false) {
        super();
        this.w = w;
        this.h = h;
        this.speed = 5;
        this.vx = 0;
        this.vy = 0;
        this.dest_control = dest_control;
        this.dest_x = 0;
        this.dest_y = 0;
        this.trigger = false; //当たり判定のみかどうか
        this.static = stc; //静止オブジェクトかどうか

        let shape = new createjs.Shape();
        shape.graphics.beginFill('white');
        shape.graphics.drawRect(0, 0, w, h);
        this.addChild(shape); // 表示リストに追加

        // メンバーフィールドに保存
        this.shape = shape;

        // 更新イベントを定義
        this.on('tick', this.update, this);
      }

      set_destination(_dest_x, _dest_y){
        this.dest_x = _dest_x;
        this.dest_y = _dest_y;
      }
      set_velocity_to_destination(){
        let angle = Math.atan2( this.dest_y-(this.y+this.h/2), this.dest_x-(this.x+this.w/2) );
        this.vx = this.speed * Math.cos(angle);
        this.vy = this.speed * Math.sin(angle);
      }

      on_collision(c_obj){ //c_obj:衝突相手(Move_Object型)
        
      }
      slide_collision(c_obj){
        if(this.trigger == false){
          let side = Func.which_side_rect(this, c_obj);
          if(side == "right"){
            this.x = c_obj.x + c_obj.w;
          }else if(side == "left"){
            this.x = c_obj.x - this.w;
          }else if(side == "down"){
            this.y = c_obj.y + c_obj.h;
          }else if(side == "up"){
            this.y = c_obj.y - this.h;
          }else{
            console.log("myError: which_side? -> no side.");
          }
        }
      }

      update() {
        if(this.dest_control==true){
          this.set_velocity_to_destination();
        }

        if( Func.check_close(this.x+this.w/2, this.y+this.h/2, this.dest_x, this.dest_y, this.speed) ){
          this.vx = 0;
          this.vy = 0;
        }

        this.x += this.vx;
        this.y += this.vy;
      }
    }

    class CollisionManager extends createjs.Container {
      constructor(){
        super();
        this.object_list = [];

        this.on('tick', this.update, this);
      }

      update(){
        
        for(let i=0; i<this.object_list.length; i++){
          for(let j=i+1; j<this.object_list.length; j++){
            if(Func.check_collision(this.object_list[i], this.object_list[j])){
              console.log("collision.");
              this.object_list[i].slide_collision(this.object_list[j]);
              this.object_list[i].on_collision(this.object_list[j]);
              this.object_list[j].on_collision(this.object_list[i]);
            }
          }
        }
      }

      addList(object){
        this.object_list.push(object);
      }

    }


    class Func {
      static check_close(x1, y1, x2, y2, d){
        if(x1 < x2+d && x1 > x2-d && y1 < y2+d && y1 > y2-d){
          return true;
        }else{
          return false;
        }
      }
      static check_collision(obj1, obj2){
        if(obj1.x+obj1.w > obj2.x && obj1.x < obj2.x+obj2.w){
          if(obj1.y+obj1.h > obj2.y && obj1.y < obj2.y+obj2.h){
            return true;
          }
        }
        return false;
      }
      /**
      * @fn
      * 座標pが座標qのどちら側(上下左右)にあるか調べる
      * @param p Vector2
      * @param q Vector2
      * @return string : right/left/up/down
      */
      static which_side_point(p, q){
        let deltax = q.x-p.x;
        let deltay = q.y-p.y;
        if(Math.abs(deltax) >= Math.abs(deltay)){
          if(deltax > 0){
            return "left"
          }else{
            return "right"
          }
        }else{
          if(deltay > 0){
            return "up"
          }else{
            return "down"
          }
        }
      }
      static which_side_rect(a, b){ //* @param a, b : MoveObject(have .x .y .w .h)
        let dict = {
          left: a.x + a.w - (b.x),
          right: b.x + b.w - (a.x),
          up: a.y + a.h - (b.y),
          down: b.y + b.h - (a.y)
        }
        let min = Infinity;
        let ans = "null.";
        for(let key in dict){
          if(dict[key] >= 0 && dict[key] < min){
            min = dict[key];
            ans = key;
          }
        }
        return ans;
      }
    }

    class Vector2{
      constructor(x, y){
        this.x = x;
        this.y = y;
      }
      static zero(){
        zero = new Vector2(0.0, 0.0);
        return zero;
      }
    }

    
  </script>
  <style>
    canvas#myCanvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="myCanvas">
  </canvas>
</body>
</html>